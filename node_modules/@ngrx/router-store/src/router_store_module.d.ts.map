{"version":3,"file":"router_store_module.d.ts","sources":["router_store_module.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA","sourcesContent":["import { InjectionToken, ModuleWithProviders, ErrorHandler } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { RuntimeChecks, Selector, Store } from '@ngrx/store';\nimport { RouterReducerState } from './reducer';\nimport { RouterStateSerializer, BaseRouterStoreState } from './serializers/base';\nimport { SerializedRouterStateSnapshot } from './serializers/default_serializer';\nexport declare type StateKeyOrSelector<T extends BaseRouterStoreState = SerializedRouterStateSnapshot> = string | Selector<any, RouterReducerState<T>>;\n/**\n * Full = Serializes the router event with DefaultRouterStateSerializer\n * Minimal = Serializes the router event with MinimalRouterStateSerializer\n */\nexport declare const enum RouterState {\n    Full = 0,\n    Minimal = 1\n}\nexport interface StoreRouterConfig<T extends BaseRouterStoreState = SerializedRouterStateSnapshot> {\n    stateKey?: StateKeyOrSelector<T>;\n    serializer?: new (...args: any[]) => RouterStateSerializer;\n    /**\n     * By default, ROUTER_NAVIGATION is dispatched before guards and resolvers run.\n     * Therefore, the action could run too soon, for example\n     * there may be a navigation cancel due to a guard saying the navigation is not allowed.\n     * To run ROUTER_NAVIGATION after guards and resolvers,\n     * set this property to NavigationActionTiming.PostActivation.\n     */\n    navigationActionTiming?: NavigationActionTiming;\n    /**\n     * Decides which router serializer should be used, if there is none provided, and the metadata on the dispatched @ngrx/router-store action payload.\n     * Set to `Full` to use the `DefaultRouterStateSerializer` and to set the angular router events as payload.\n     * Set to `Minimal` to use the `MinimalRouterStateSerializer` and to set a minimal router event with the navigation id and url as payload.\n     */\n    routerState?: RouterState;\n}\nexport declare enum NavigationActionTiming {\n    PreActivation = 1,\n    PostActivation = 2\n}\nexport declare const _ROUTER_CONFIG: InjectionToken<unknown>;\nexport declare const ROUTER_CONFIG: InjectionToken<unknown>;\nexport declare const DEFAULT_ROUTER_FEATURENAME = \"router\";\nexport declare function _createRouterConfig(config: StoreRouterConfig): StoreRouterConfig;\n/**\n * Connects RouterModule with StoreModule.\n *\n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n *\n * ```\n * export type RouterNavigationPayload = {\n *   routerState: SerializedRouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n *\n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n *\n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n *\n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n *\n * Usage:\n *\n * ```typescript\n * @NgModule({\n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.forRoot(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule.forRoot()\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\nexport declare class StoreRouterConnectingModule {\n    private store;\n    private router;\n    private serializer;\n    private errorHandler;\n    private readonly config;\n    private readonly activeRuntimeChecks;\n    private lastEvent;\n    private routerState;\n    private storeState;\n    private trigger;\n    private readonly stateKey;\n    static forRoot<T extends BaseRouterStoreState = SerializedRouterStateSnapshot>(config?: StoreRouterConfig<T>): ModuleWithProviders<StoreRouterConnectingModule>;\n    constructor(store: Store<any>, router: Router, serializer: RouterStateSerializer<SerializedRouterStateSnapshot>, errorHandler: ErrorHandler, config: StoreRouterConfig, activeRuntimeChecks: RuntimeChecks);\n    private setUpStoreStateListener;\n    private navigateIfNeeded;\n    private setUpRouterEventsListener;\n    private dispatchRouterRequest;\n    private dispatchRouterNavigation;\n    private dispatchRouterCancel;\n    private dispatchRouterError;\n    private dispatchRouterNavigated;\n    private dispatchRouterAction;\n    private reset;\n}\n"]}